# 커스텀 페이지네이션

커스텀 페이지네이션은 Spring Pageable 등 기본적인 OFFSET 기반 대신, 도메인/성능 요구에 맞춘 전용 로직으로 데이터를 분할 조회하는 방식이다. 대규모 데이터셋, 실시간 정렬 변경, 무한 스크롤(인피니트 스크롤) 같은 시나리오에서 특히 유용하다!

## 기본 페이지네이션 vs 커스텀 페이지네이션

| 구분 | 방식 | 장점 | 단점 |
| --- | --- | --- | --- |
| **기본 페이지네이션 (OFFSET/LIMIT)** | `OFFSET x LIMIT y` 사용 | 직관적, 구현 쉬움 | 데이터 많을수록 느림 (OFFSET 비용 증가) |
| **커스텀 페이지네이션** | 커서 기반, 토큰 방식 등 | 대규모 데이터 성능 우수, 무한스크롤 적합 | 설계 복잡, 정렬 기준명확 필요 |

OFFSET 방식은 요청 위치까지 도달하기 위해 앞선 모든 행을 스캔한 뒤 폐기하는 과정이 필요하므로, 예를 들어 OFFSET 90000일 경우 DB가 먼저 9만 개의 행을 읽고 버린 후에야 원하는 결과를 반환하게 된다. 인덱스를 사용하더라도 지정된 범위의 인덱스를 순회한 뒤 실제 튜플(데이터 페이지)에 접근하는 비용이 누적되므로, 페이지가 뒤로 갈수록 성능이 급격히 저하되는 방식이라 할 수 있다.

### 커스텀 페이지네이션이 필요한 상황

| 상황 | 설명 |
| --- | --- |
| 무한 스크롤 UI | “더보기” 또는 자동 스크롤 |
| 정렬 조건이 복잡한 경우 | 시간 + 인기순 + 거리순 등 |
| 대규모 테이블 | 수십만~수백만 row |
| 실시간성 요구 | 채팅, 알림, 로그 조회 |
| ID 기반 탐색 | SNS 피드 (Instagram/Twitter 스타일) |

---

## 대표적인 커스텀 페이지네이션 방식

### 1) **Cursor Based Pagination (Keyset Pagination)**

- 가장 일반적인 고성능 방식
- 기준 컬럼을 `>`/`<` 비교로 페이징

예: createdAt 기준

```sql
SELECT *
FROM posts
WHERE created_at < :lastSeenTime
ORDER BY created_at DESC
LIMIT 20;
```

- **OFFSET 없이 바로 다음 데이터**
- 역정렬 지원 가능 (prev cursor)

### 2) **Hybrid 방식 (커서 + 조건 필터링)**

- 단순 키 하나가 아니라 **상태(Id, createdAt, distance 등)** 조합

예: 댓글 목록 ID + 좋아요순

```sql
WHERE (likes, id) < (:lastLikes, :lastId)
```

### 3) **토큰 기반 페이지네이션**

- 커서 정보를 인코딩하여 클라이언트 전달
- Firebase, GraphQL, Hasura 등에서 채택

예: `nextToken = "eyJpZCI6MTIzLCJj...=="`