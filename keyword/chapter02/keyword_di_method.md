워크북의 예시를 기준으로 **필드 주입 / 생성자 주입 / 수정자 주입**은 결국 `@Autowired`를 **어디에 붙이느냐**에 따라 달라진다. 

## @Autowired

`@Autowired`는 DI(의존성 주입)를 표시하는 어노테이션이다.

스프링 컨테이너는 애플리케이션 시작 시 `@Component`가 붙은 클래스를 찾아서 **빈으로 등록**한다. 이때 클래스 안에 `@Autowired`가 붙어 있는 지점을 확인하고, **“여기는 의존성을 주입해야 하는 곳이구나**”라고 인식한다.

그다음 스프링 컨테이너는 주입 대상의 **타입(Type)** 을 기준으로 빈을 검색한다.

- 같은 타입의 빈이 정확히 하나 있으면 → 바로 주입
- 같은 타입의 빈이 여러 개 있으면 → `@Primary`가 우선권, `@Qualifier`로 직접 지정 가능
- 같은 타입의 빈이 없으면 → 기본적으로 에러 발생 (`NoSuchBeanDefinitionException`)

> 스프링의 계층별 특화된 어노테이션 안에는 이미 @Component 가 있음
> 

ex) `@Controller` , `@Repository` , `@Service`

> 컨포넌트 스캔을 통해서 안 하고, `@Configuration` +`@Bean` 을 통해도 가능
> 

`@Configuration`이 붙은 설정 클래스 안에서, 각 메서드에 `@Bean`을 붙여주면 스프링이 그 메서드를 실행해서 반환 객체를 빈으로 등록한다. 이때 실제 객체를 생성하려고 보니 생성자에서 다른 의존성이 필요할 수 있다. 그러면 스프링 컨테이너는 이미 등록된 빈을 찾아서 대신 넣어주는 것이다. 개발자가 “이 빈은 이렇게 조립해!”라고 하나하나 알려주면, 스프링이 그 과정을 실행하고 관리해주는 방식으로 자동 등록(@ComponentScan)과 달리 직접 등록하는 방식이라 **수동 등록** 같은 느낌을 준다!


## 생성자 주입

**생성자 주입**은 객체가 생성될 때 필요한 의존성을 모두 함께 넣어주는 방식이다.

태어날 때부터 필요한 걸 다 갖추고 시작하니, 이후 의존성 때문에 삐걱거릴 일이 없다. 말 그대로 “금수저” 느낌이다.

```java
@Component
public class OrderService {
    private final DiscountPolicy discountPolicy;

    // 생성자 주입
    @Autowired // 생성자가 하나뿐이면 @Autowired 생략 가능
    public OrderService(DiscountPolicy discountPolicy) {
        this.discountPolicy = discountPolicy;
    }

    public int createOrder(int price) {
        return discountPolicy.discount(price);
    }
}
```

스프링이 애플리케이션을 시작할 때 `@Component`가 붙은 클래스를 발견한다.

**“이 클래스는 빈으로 등록해야겠네?”** 하고 객체 생성을 시작한다.

객체를 생성할 때는 당연히 생성자가 호출된다. 스프링은 이미 클래스를 분석하면서 생성자에 `@Autowired`가 붙어 있음을 확인하고, 이 생성자가 **의존성 주입 대상**임을 파악한다. 그 후 스프링 컨테이너에서 알맞은 빈을 미리 찾아낸 뒤, 그 빈을 생성자 파라미터에 넣어 호출하여 객체를 생성한다.

결국 **객체가 생성되는 동시에 필요한 의존성이 주입되어, 완전한 상태로 컨테이너에 등록**된다.

### 불변성을 보장한다

생성자 주입을 사용하면 의존성 필드에 **`final`** 을 붙일 수 있다. 즉, 객체가 생성될 때 주입된 의존성은 이후 절대 바뀌지 않는다는 사실을 코드 차원에서 보장할 수 있다.

처음엔 “중간에 바꿀 수 있으면 더 유연하지 않을까?”라고 생각할 수 있다.

하지만 실무에서는 사람이 실수할 가능성이 항상 존재한다. 예를 들어 setter를 잘못 호출하면 런타임에서 문제로 이어지고, 로깅은 단지 **사후 확인**일 뿐 이미 사고가 난 뒤에야 알 수 있다.

따라서 **변경될 이유가 없는 의존성**이라면 `final`을 사용해 **컴파일 단계에서 변경 자체를 막는 편이 훨씬 안전하다.** 사람의 주의나 규칙보다 **언어와 컴파일러의 제약**이 더 믿을 만하기 때문이다. 결론적으로, **생성자 주입 + `final` 조합**이 가장 안전하고 유지보수에 유리한 방식이다.

### 누락된 의존성은 애초에 실행 단계 전에 잡힌다

생성자 주입에서 필수 의존성을 주입하지 않으면 **객체가 아예 생성되지 않는다.**

따라서 서버가 뜬 뒤에 NPE로 터지는 대신, **애플리케이션 시작 시점**에 바로 에러가 발생해 문제를 초기에 잡을 수 있다.

> **기본값을 두면 되지 않나?**
> 

기본값을 두면 실행은 될 수 있지만, 이는 **설계 의도와 충돌**한다. 생성자 주입의 핵심은 “모든 필수 의존성이 주입된 상태로 시작”하는 것이다. 기본값이 있으면 테스트나 특정 환경에서 의존성 누락이 가려져 버그를 **늦게** 발견할 수 있다. 실제 운영 단계에서 터지면 의미가 없다. **필수 의존성에는 기본값을 두지 않는 것**이 바람직하다.

### 순환 참조를 사전에 감지한다

스프링은 컨테이너를 띄울 때 **생성자를 통해 미리 의존성을 주입**한다. 이 과정에서 `A ↔ B` 같은 **순환 참조**가 있으면 **컨테이너 로딩 단계에서 즉시 오류**를 내고 실행을 멈춘다.

실행 도중이 아니라 **실행 전**에 터지는 오류가 가장 좋은 오류다. 초기 단계에서 바로 수정할 수 있기 때문이다.


## 수정자 주입

수정자 주입은 “생성자 주입과 달리 의존성이 나중에 바뀔 수도 있다”라는 의도로 사용하는 방식이다. 

```java
@Component
public class OrderService {
    private DiscountPolicy discountPolicy;

    // 수정자 주입 (Setter 주입)
    @Autowired
    public void setDiscountPolicy(DiscountPolicy discountPolicy) {
        this.discountPolicy = discountPolicy;
    }

    public int createOrder(int price) {
        return discountPolicy.discount(price);
    }
}
```

`@Component`가 붙어 있으니까 스프링이 해당 객체를 생성하고 빈으로 등록한다.

객체를 만들기 위해 생성자를 호출했지만, 이 시점에는 의존성이 주입되지 않아 필드 값은 `null` 상태다. 그 후 스프링은 생성된 객체를 한 번 훑으면서 `@Autowired`가 붙은 수정자(setter)를 발견한다. 이때 컨테이너에서 알맞은 빈을 찾아 수정자 메서드를 호출하면서 주입한다. 결과적으로 객체에는 의존성이 정상적으로 연결된다.

그리고 런타임 도중에 `setDiscountPolicy()` 메서드를 다시 호출하면, 새로운 인스턴스가 주입되면서 의존성이 변경될 수 있다.

생성자 주입은 의존성이 주입되지 않으면 객체 생성 자체가 불가능하다. 왜냐하면 생성자를 호출할 때 필요한 파라미터(즉, 의존성)가 없으면 객체를 만들 수 없기 때문이다.

반면 수정자 주입은 객체를 먼저 생성한 뒤, 스프링이 객체를 훑는 과정에서 `@Autowired`가 붙은 setter 메서드를 호출해 의존성을 주입한다. 따라서 의존성이 없어도 일단 객체는 생성된다.

또한 `@Autowired(required = false)` 옵션을 사용하면 해당 의존성을 선택적으로 주입할 수 있으며, 주입 대상이 없더라도 오류 없이 넘어간다.

> 여기서 내가 말한 훑는 과정을 **BeanPostProcessor, 빈 후 처리 과정**이라고 한다.
> 

**장점**: 필요한 경우 런타임에 의존성을 교체할 수 있다.

**단점**: 의존성이 주입되지 않아도 객체 자체는 생성되기 때문에, 잘못 사용하면 NPE가 발생할 수 있다.


## 필드 주입

필드 자체에 @Autowired 를 붙인다.

```java
@Component
public class OrderService {
    
    @Autowired
    private DiscountPolicy discountPolicy;
    
}
```

`@Component`를 통해 객체가 생성될 때는 의존성이 아직 주입되지 않는다.

그러나 이후 스프링의 **빈 후처리 과정**을 거치면서 의존성이 주입된다.

이때 **수정자 주입**은 `@Autowired`가 붙은 setter 메서드를 스프링이 직접 호출하여 주입하는 방식이고, **필드 주입**은 `@Autowired`가 붙은 필드를 **리플렉션(Reflection)** 으로 열어서 값을 직접 할당하는 방식이다.

<aside>

### 리플렉션이란?

자바에서 클래스의 **메타데이터(Class, Method, Field 등)** 에 런타임에 접근할 수 있는 기능을 말한다. 

```java
field.setAccessible(true);
field.set(instance, value);
```

원래 `private` 필드는 외부에서 직접 접근할 수 없지만, 위와 같이 막을 풀고 값을 강제로 주입할 수 있다. 스프링은 이 메커니즘을 활용해 `@Autowired` 필드에 빈을 넣어준다.

</aside>

**장점**: 코드 간단, 한 줄만 써도 의존성 주입됨.

**단점**

**테스트하기 어려움**

테스트 코드에서 **생성자 주입**이라면 의존성을 직접 만들어서 생성자에 넣어주기만 하면 된다. 그러나 **필드 주입**은 단순히 `new` 로 객체를 생성해도 의존성이 주입되지 않는다. 스프링 컨테이너가 있어야 `@Autowired`가 동작하기 때문이다. 만약 컨테이너 없이 테스트하려면, 리플렉션을 사용해 필드에 직접 값을 할당해야 한다.

**설계 불투명성**: 코드(생성자/메서드 시그니처)만 봐서는 필요한 빈을 알기 어렵고, 컨테이너 설정을 열어봐야 파악된다.

**불변성 보장 X:** 필드 주입은 **객체 생성 후에 값이 세팅**되므로, 생성 시점에 완성된 불변 상태가 아니다. 게다가 필드가 `final`이 아닐 가능성이 크고(대개 `final` 못 씀), **리플렉션으로 재할당**도 가능해 **진짜 불변성 보장** 을 하지 않는다.