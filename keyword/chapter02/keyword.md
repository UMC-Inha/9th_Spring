## 🎯 핵심 키워드





- **SOLID**
    
    SOLID : 객체 지향 설계의 5원칙이다. 이 원칙을 지키면 시간이 지나도 변경이 용이하고 유지보와 확장이 쉬운 소프트웨어를 개발할 수 있다.
    
    S : 단일 책임 원칙 ( Single Responsibility Principle)
    
    O : 개방 폐쇄 원칙 (Open Closed Priciple)
    
    L : 리스코프 치환 원칙 (Liskov Substitution Principle)
    
    I : 인터페이스 분리 원칙 (Interface Segregation Principle)
    
    D : 의존 역전 원칙 (Dependency Inversion Principle)
    
    ## 1. 단일 책임 원칙
    
    - 클래스(객체)는 단 하나의 책임만 가져야 한다는 원칙이다. 여기서 책임은 하나의 기능 담당이다. 하나의 클래스는 하나의 기능을 담당하여 하나의 책임을 수행할 수 있도록 클래스를 따로 설계하라는 원칙이다.
    - 만일 하나의 클래스에 여러 책임이 있다면 기능 변경이 일어났을 때 수정 사항이 많아지고 책임이 순환되는 형태가 될 수 있다. 단일 책임 원칙을 적용하면 한 책임의 변경으로부터 다른 책임의 변경으로의 연쇄 작용을 극복할 수 있다.
    
    ## 2. 개방 폐쇄 원칙
    
    - 확장에 열려있어야 하며 수정에는 닫혀있어야 한다는 원칙이다. 기능의 추가가 발생했을 때, 클래스의 확장을 통해 구현이 가능하고, 확장에 따른 클래스 수정은 최소화하도록 프로그램을 설계하는 기법이다.
    - 즉, 새 요구가 생겨도 기존 코드를 고치지 않고 새 코드를 덧붙여서(확장) 해결하라는 설계 원칙이다.
    - 요구사항이 바뀔 때 마다 기존 클래스를 고치면 연쇄적인 수정이 필요할 수 있기 떄문에 기존의 안정 영역을 고정시키고, 변화는 확장하는 방식.
    
    ## 3. 리스코프 치환 원칙
    
    - 서브 타입은 언제나 부모 타입으로 교체할 수 있어야 한다는 원칙이다. 즉, 다형성 원리를 이용하기 위한 원칙이라고 생각하면 된다. 다형성의 특징을 이용하기 위해 상위 클래스타입으로 객체를 선언하여 하위 클래스의 인스턴스를 받으면, 업캐스팅된 상태에서 부모의 메서드를 사용해도 동작이 의도대로 흘러가야한다는 것을 의미한다.
    - 부모 클래스 객체를 사용하는 코드에서 자식 클래스로 바꿔도 프로그램의 기능이 깨지지 않아야 한다.
    - “사각형은 직사각형이다” ← 이런 식으로 겉보기에는 맞는 것 같아도 상속 관계가 어긋난 경우를 주의해야 한다. 한다는 것이다. 부모가 가진 계약을 자식이 반드시 지켜야 한다. ( 사각
    - 쉽게 말해서 자식은 부모의 규칙을 지켜야 한다.
    
    ## 4. 인터페이스 분리 원칙
    
    - 한마디로, “자신이 사용하지 않는 메서드에 의존하지 않아야 한다”는 것이다.
    - 하나의 거대한 인터페이스에 너무 많은 메서드가 있으면, 구현체는 쓰지도 않는 메서드를 억지로 구현해야 한다. → 불필요한 의존성이 증가하고, 변경에 따른 영향 범위가 커진다.
    - 작은 인터페이스 여러개가 하나의 거대한 인터페이스보다 백배 낫다!  잘 쪼개자
    
    ## 5. 의존 역전 원칙
    
    - 고수준의 정책 또는 비즈니스 규칙은 저수준에 의존하면 안된다. 둘 다 인터페이스에 이존해야 한다는 원칙이다. 인터페이스는 구체적인 것에 의존하지 않고, 구체적인 것이 인터페이스에 의존해야 한다.인 것에
    - 즉, 정책 코드나 DB 같은 세부 구현에 의존하지 말고, 추상화한 인터페이스에 의존하라는 것이다. 이렇게 해야 구현이 바뀌어도 수정을 최소화할 수 있다.
    - 간단히 말하면 인터페이스를 사용하라는 것이다.
    
- **DI**
    
    ## DI (Dependency Injection) 이란?
    
    외부에서 두 객체 간의 관계를 결정해주는 디자인 패턴으로, 인터페이스를 사이에 둬서 클래스 레벨에서는 의존 관계가 고정되지 않도록 하고 런타임 시에 관계를 동적으로 주입해주는 것을 말한다.
    
     즉, 객체간의 의존 관계를 개발자가 직접 생성하지 않고, 스프링 컨테이너가 대신 주입해주는 것이다. 
    
    의존성이란? 
    
    어떤 클래스가 다른 클래스를 사용해야 할 때 그 객체를 의존한다고 말한다.
    
    DI가 왜 필요할까?
    
    - 결합도 낮추기 : 직접 new를 통해 객체를 만들면 클래스 간 결합도가 높아져, 테스트와 확장이 어렵다. 반면, 스프링이 객체 생성을 관리하면, 인터페이스 기반으로 코드를 짜고 쉽게 교체가 가능하다.
    - 재사용성 증가 : 같은 코드를 다양한 상황에서 활용이 가능하다.
    
    스프링은 의존성 주입을 도와주는 DI 컨테이너로서, 강하게 결합된 클래스를 분리하고, 애플리케이션 실행 시점에 객체 간의 관계를 결정해줌으로써 결합도를 낮추고 유연성을 확보해준다. 
    
    이러한 방법은 상속보다 훨씬 유연하다. 단, 한 객체가 다른 객체를 주입받으려면 반드시 DI 컨테이너에 의해 관리되어야 한다.  
    
- **IoC**
    
    ## IoC (Inversion of Control) 이란?
    
    프로그램의 제어 흐름을 개발자가 직접 제어하는 것이 아니라, 외부(스프링 컨테이너) 가 제어하는 것을 말한다.
    
    원래대로라면 개발자가 직접 new를 통해 객체를 생성하고 관리해야 하지만, IoC를 적용하면 이런 객체 생성과 생명주기에 관한 관리 제어권이 개발자에서 스프링으로 넘어간다. 
    
    즉, 개발자는 “무엇을 할 지”에 집중하고, 언제/어떻게 실행할지는 스프링이 알아서 해주는 구조라고 생각하면 된다.ㅈ
    
    DI는 IoC를 구현하는 방법 중 하나다. 스프링에서는 IoC를 DI를 통해 구현한다.
    
    스프링은 IoC 컨테이너를 통해 객체(빈)를 생성하고, 관리하며, 필요할 때 주입해준다.
    
    객체 생성과 주입을 스프링 컨테이너 즉, DI 컨테이너가 담당하며, 제어권이 개발자에서 스프링으로 넘어가게 되는 것이다. 
    
- **생성자 주입 vs 수정자, 필드 주입 차이**
    
    
    ## 1. 생성자 주입 방법
    
    필요한 의존성을 생성자 파라미터로 주입받는 방식이다.
    
    생성자의 호출 시점에 1회 호출되는 것이 보장되며, 그렇기 때문에 주입받은 객체가 변하지 않거나, 반드시 객체의 주입이 필요한 경우에 강제하기 위해 사용할 수 있다.
    
    스프링 프레임워크에서는 생성자 주입 방식을 권장하고 있다.
    
    ### 자세한 설명
    
    - final 필드를 사용하여 런타임에 바뀌지 않으므로 불변성을 보장한다.
    - 생성자가 존재하지 않으면 객체를 만들 수 없으니 컴파일/런타임 초기(조기)에 문제를 발견할 수 있다.
    - 순환 참조를 조기에 검출할 수 있다 → 서로의 생성자에서 요구하면 바로 확인이 가능하다.
    - 스프링 없이도 생성자에 목 데이터를 넣어 단위 테스트가 가능하다
    - 생성자 1개만 있을 경우에 @Autowired 를 생략해도 주입이 가능하도록 편의성을 제공한다. (뭔 말인지 잘 모르겠음)
    
    ## 2. 수정자 주입 방법 (Setter 주입 방법)
    
    필드 값을 변경하는 Setter 메서드를 이용해서 의존관계를 주입하는 방식이다. Setter 주입은 생성자 주입과는 다르게 주입받는 객체가 변경될 가능성이 있는 경우에 사용한다. 
    
    ### 자세한 설명
    
    - 스프링이 객체를 생성한 후 set~() 메서드를 호출해서 필요한 빈을 넣어준다.
    - 런타임에 교체 가능하기 때문에 동적으로 빈을 바꿔끼우는 테스트나 설정 상황에서 유용하다.
    - 객체가 완전히 생성된 이후에 의존성이 들어오기 때문에 불변성 보장이 어렵다.
    - 주입을 빼먹어도 컴파일 단계에서 확인하기 어렵다.→이 또한 객체가 생성되고나서 의존성이 들어오기 때문
    
    일반적으로 수정자 주입은 필수 의존성이 아닌 선택적 의존성에만 한정적으로 사용하고, 그 외에는 생성자 주입을 표준으로 삼는 것이 가장 안전하다. 
    
    ## 3. 필드 주입 방법
    
    의존성을 클래스 내부의 필드에 바로 의존 관계를 주입하는 방법이다. 
    
    @Autowired 해서 주입한다. 가장 코드가 짧고 단순하지만, 테스트/유지보수 측면에서 단점이 많아, 실무에서는 권장되지 않는 방식이다. 
    
    ### 자세한 설명
    
    - 가장 단순해서 코드의 양이 적고 바로 의존성을 사용할 수 있다.
    - final 키워드를 사용할 수 없으므로 불변성을 보장할 수 없다.
    - 외부에서 접근이 불가능하다.
    - @Autowired 키워드 없이는 객체가 정상 동작하지 않는다. → 반드시 DI 프레임워크가 존재해야 한다.
    - 생성자 주입은 애플리케이션 시작 시점에서 바로 에러가 나지만, 필드 주입은 런타임에 늦게 드러나기도 한다.
    - 빠르게 의존성을 연결할 때 간단하게 주입할 수 있기 때문에 데모 프로젝트나 테스트용으로 적합하다.
    
    ## 생성자 주입을 사용해야 하는 이유
    
    1. 객체의 불변성 확보
    
    의존 관계의 변경이 필요한 상황은 거의 없지만, 다른 주입방식을 이요하면 불필요하게 수정의 가능성을 열어 두기 때문에 유지보수성을 떨어뜨린다. 따라서 생성자 주입을 통해 변경의 가능성을 배제하고 불변성을 보장하는 것이 좋다.
    
    1. 테스트 코드의 작성
    
    테스트가 특정 프레임워크에 의존하는 것은 좋지 못하다. 생성자 주입이 아닌 코드로 작성하면, 순수 자바 코드로 단위테스트를 작성하는 것이 어렵다.
    
    1. final 키워드 작성 및 Lombok과의 결합
    
    생성자 주입을 사용하면 필드 객체에 final 키워드를 사용할 수 있으며, 컴파일 시점에 누락된 의존성을 확인할 수 있다. 반면에 다른 주입방법들은 final 키워드를 사용할 수 없다. 
    
    또한 final 키워드를 붙이면 Lombok과 결합되어 코드를 간결하게 작성할 수 있다. 
    
    - Lombok이란?
        
        어노테이션 기반으로 코드를 자동완성 해주는 라이브러리이다. Lombok을 활용하면 Getter, Setter, Equlas, ToString 등과 같은 다양한 방면의 코드를 자동완성 시킬 수 있다. 
        
        장점
        
        - 어노테이션 기반의 코드 자동 생성을 통한 생산성 향상
        - 반복되는 코드 다이어트를 통한 가독성 및 유지보수성 향상
        - 빌더 패턴이나 로그 생성 등 다양한 방면으로 활용 가능
    1. 스프링에 비침투적인 코드 작성
    
    필드 주입을 하려면 @Autowired를 이용해야 하는데, 이것은 스프링이 제공하는 어노테이션이다. 따라서 사용하면 스프링 의존성이 침투하게 되는데, 프레임워크가 언제 바뀔지도 모르고, 민감한 정보에 관한 책임을 지는 코드에 스프링이 박혀버리면 좋지 않다. 
    
    1. 순환 참조 에러 방지
    
    생성자 주입을 사용하면 어플리케이션 구동 시점에 순환 참조 에러를 예방할 수 있다.  
    
- **AOP**
    
    ## AOP (Aspect Oriented Programming) 이란?
    
    AOP는 관점 지향 프로그래밍. 즉, 핵심 비즈니스 로직과 부가 기능을 분리하여 모듈화 하는 개념이다. 여기서 모듈화란 어떤 공통된 로직이나 기능을 하나의 단위로 묶는 것을 말한다. 
    
    예) 
    
    핵심 로직: 실제 비즈니스 목적 (주문 생성, 결제 처리) 
    
    부가 기능: 로깅 보안 검사, 트랜잭션 관리, 성능 측정 
    
    부가기능은 보통 여러 클래스와 메서드에 중복해서 들어가게 되는데, AOP에서는 이 중복되는 부가 기능을 따로 모듈화해서 공통으로 적용할 수 있도록 한다.
    
    ### 핵심 개념
    
    1. Aspect (관점) : 공통 기능을 모듈화 한 것.
    2. Target : Advice가 적용될 객체
    3. Join Point : 공통 기능을 적용할 수 있는 지점(메서드 호출 시점, 객체 생성 시점 등)
    4. Pointcut : 어디에 공통 기능을 적용할 지 지정하는 규칙
    5. Advice : 실제 실행될 부가 기능 코드 
    6. Weaving : pointcut에 따라 Aspect를 핵심 코드에 적용하는 과정
    
- **서블릿**
    
    ## 서블릿이란?
    
    클라이언트의 요청을 처리하고, 그 결과를 다시 클라이언트에게 전송하는 Servlet 클래스의 구현 규칙을 지킨 자바 프로그램이다.
    
    동적인 페이지를 가공하기 위해 웹 서버가 다른 곳에 도움을 요청한 후 가공된 페이지를 넘겨주게 되는데, 이때 서블릿을 사용하게 되면 웹페이지를 동적으로 생성하여 클라이언트에게 반환해줄 수 있다. 
    
    개발자는 서블릿이 요구하는 구현 규칙을 지키면서 서블릿을 정의해주면 요청과 응답을 쉽게 처리할 수 있게 되었다. 
    
    일반 자바 객체와의 차이점?
    
    서블릿은 main() 메서드로 직접 호출되지 않고, 서블릿 컨테이너에 의해 실행된다. 컨테이너가 web.xml을 읽고 서블릿 클래스를 클래스 로더에 등록하는 절차를 밟는다. 
    
    ### 서블릿 컨테이너란?
    
    구현되어있는 servlet 클래스의 규칙에 맞게 서블릿 객체를 생성, 초기화, 호출, 종료하는 생명 주기를 관리한다.
    
    서블릿 컨테이너는 클라이언트의 요청을 받고 응답할 수 있도록 웹 서버와 소켓으로 통신한다.
    
    대표적인 컨테이너로는 Tomcat이 있다.
    
    여기서 DI 컨테이너와 헷갈렸는데, 한마디로 정리하면
    
    서블릿 컨테이너 = 웹 요청을 관리하는 관리자
    
    DI 컨테이너 = 객체(Bean)를 관리하는 관리자
    
    서블릿 객체와 일반 Bean으로 선언되는 객체는 다르다. 
    
    서블릿은 HTTP 요청과 응답을 처리하고, DI 컨테이너는 객체를 생성/주입하고, 객체의 생애주기를 관리한다. 
    
    ### 서블릿의 동작 흐름
    
    1. 사용자가 브라우저에서 URL을 요청함
    2. 웹 서버가 요청을 받음 → Tomcat과 같은 WAS에게 전달
    3. WAS는해당 URL 패턴에 매핑된 서블릿 클래스를 실행
    4. 서블릿이 요청을 처리 (doGet, doPost 등의 메서드 실행)
    5. 결과를 HTTPResponse 객체로 클라이언트에게 반환
    
    - WAS란?
        
        WAS는 웹 서버와 웹 애플리케이션 실행 환경을 합친 개념이다.
        
        클라이언트의 요청을 받아서 단순한 정적 파일만 주는 게 아니라, 스프링, JSP, servlet과 같은 동적인 로직을 실행해서 응답을 만들어 줄 수 있는 서버다. 
        
        ### 톰캣의 특징
        
        - **Apache Tomcat**은 **자바 기반**의 오픈소스 WAS
        - 자바 EE(Java Enterprise Edition) 표준 중 일부(서블릿, JSP)를 구현한 서버
        - 주요 역할:
            1. HTTP 요청을 받아 서블릿 컨테이너를 통해 서블릿 실행
            2. JSP를 서블릿으로 변환 후 실행
            3. 세션 관리, 멀티스레딩 관리
            4. Spring 같은 프레임워크가 올라갈 실행 환경 제공
        
         즉, 톰캣은 **서블릿 컨테이너 기능 + WAS 역할**을 동시에 수행한다. 
        
    
- Optional 클래스
    
    ## Optional이란?
    
    Optional 클래스는 null이 올 수 있는 값을 감싸는 Wrapper 클래스로, 참조하더라도 NPE (NullPointerException)가 발생하지 않도록 도와준다. 
    
    Optional 클래스는 값이 null이라도 바로 NPE가 발생하지 않으며, 각종 메서드를 제공한다.
    
    값이 없을 수도 있다는 사실을 명확하게 표현할 수 있게 해준다.
    
    - NPE (NullPointerException)란?
        - **자바에서 가장 흔히 발생하는 런타임 예외** 중 하나
        - 말 그대로 (아무것도 참조하지 않는 상태)인 객체에 접근하려고 할 때 발생한다
        - 즉, 객체가 메모리에 없는데 마치 있는 것처럼 사용하려고 하면 터진다.
        
        언제 발생할까?
        
        1. 객체를 초기화하지 않고 사용했을 때
        2. 메서드 리턴 값이 null인데 체크하지 않고 사용했을 때
        3. 배열이나 컬렉션 안의 요소가 null일 때
    
    Optional은 메서드가 null을 반환할 수도 있을 때 쓰면 좋다.
    
- Stream API
    
    ## Stream API란?
    
    데이터를 선언적이고 함수형 스타일로 처리할 수 있게 해주는 API이다.
    
    여기서 Stream은 데이터를 담는 저장소가 아니라 데이터를 처리하는 흐름이다. 
    
    한번 생성된 stream은 한 번만 소비할 수 있고, 재사용하려면 새로 만들어야 한다. 
    
    ### 특징
    
    1. 원본의 데이터를 변경하지 않는다.
    
    Stream API는 원본의 데이터를 조회해서 원본의 데이터가 아닌 별도의 요소들로 Stream을 생성한다. 그렇기 때문에 원본의 데이터로부터 읽기만 할 뿐이고, 정렬이나 필터링 작업은 별도의 Stream 요소들에서 한다.
    
    1. 일회용이다
    
    Stream API는 일회용이기 때문에 한 번 사용이 끝나면 재사용이 불가능하다. Stream이 또 필요한 경우에는 Stream을 다시 생성해 주여야 한다. 만약 닫힌 Stream을 다시 사용한다면 IlligalStrateExeption이 발생하게 된다.
    
    1. 내부 반복으로 작업을 처리한다.
    
    Stream을 이용하면 코드가 간결해지는 이유 중 하나는 내부 반복 때문이다. 기존에는 반복문을 사용하기 위해서 for이나 while같은 문법을 사용해야 했지만, stream에서는 그러한 반복 문법을 메서드 내부에 숨기고 있어서 보다 간결한 코드 작성이 가능하다.  
    
    ### Stream API의 세 가지 단계
    
    1. 생성하기
    - Stream 객체를 생성하는 단계이다.  재사용이 불가능하므로 닫히면 다시 생성해주어야 한다.
    1. 가공하기 
    - 원본의 데이터를 별도의 데이터로 가공하기 위한 중간 연산이다.
    - 연산 결과를 Stream으로 다시 반환하기 때문에 연속해서 중간 연산을 이어갈 수 있다.
    1. 결과 만들기
    - 가공된 데이터로부터 원하는 결과를 만들기 위한 최종 연산이다.
    - Stream 요소들을 소모하면서 연산이 수행되기 때문에 1번만 처리가 가능하다.
    
    Stream 연산들은 매개변수로 함수형 인터페이스를 받는다.
    
    - 함수형 인터페이스란?
        
        함수를 1급 객체처럼 다룰 수 있게 해 주는 어노테이션으로, 인터페이스에 선언하여 단 하나의 추상 메서드만을 갖도록 제한하는 역할을 한다.