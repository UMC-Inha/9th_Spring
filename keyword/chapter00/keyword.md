- **외래키**

  하나의 테이블을 다른 테이블에 의존하게 만든다.

  한 테이블의 필드가 다른 테이블의 기본 키를 참조하는 것이다.

  이때 부모 테이블의 기본 키가 자식 테이블의 일반 속성이라면 비식별 관계, 부모 테이블의 기본 키가 자식 테이블의 기본 키에 존재한다면 식별 관계라고 부른다.


- **기본키**

  테이블 내에서 각 row를 식별할 수 있게 하는 column이다.

  기본적으로 NOT NULL이어야 하고 중복값이 있으면 안된다.

  기본키는 단일 컬럼으로 이루어질 수도, 복합 컬럼으로 이루어질 수도 있다. 다만, 꼭 필요한 컬럼만 PK로 사용해야 한다.

  또한, 한번 정해진 primary key 값은 바뀌면 안된다. (웬만하면)


- **ER 다이어그램**

  ERD는 entity, relationship, attribute 3가지를 시각적으로 표현한 그림이다. 개념적, 논리적 모델링 단계에서 사용한다.


- **복합 키**

  하나의 컬럼이 아닌 두개 이상의 컬럼으로 구성된 기본키이다. 하나의 컬럼만으로 각 row를 고유하게 식별해낼 수 없을 때 여러 개의 컬럼으로 기본키를 구성한다.


- **연관관계**

  엔티티간의 관계를 나타낼 때는 1:1, N:1, 1:N, N:M 관계가 있다.

  1:1 관계 → 엔티티 양쪽에 하나씩 존재하는 관계이다.

  1:N 관계 → 엔티티 하나의 행에 다른 엔티티의 행이 여러 개 있는 관계이다. ex) 한 사람은 강아지를 여러마리 키울 수 있다.

  N:M 관계 → 엔티티 양쪽 모두 하나 이상과 연결될 수 있는 관계이다. ex) 한 학생은 여러 강의를 수강할 수 있고, 한 강의는 여러 학생이 들을 수 있다.


- **정규화**

  데이터의 **중복을 허용하지 않는 방식**으로 테이블을 설계하는 방식을 정규화라고 한다.

  하나의 엔티티의 많은 컬럼을 넣게 되면, 엔티티를 조회할 때 마다 많은 양의 데이터가 조회될 것이므로 **최소한의 데이터만을 하나의 엔티티에 넣는식으로 데이터를 분해하는 과정**이다.

  - 제 1 정규화(1NF) → 테이블의 컬럼이 원자성(한 속성이 하나의 값을 갖는 특성)을 갖도록 테이블을 분해하는 단계

  - 제 2 정규화(2NF) → 제 1 정규화를 진행한 테이블에서 완전 함수 종속을 만들도록 테이블을 분해하는 단계. → 완전 함수 종속이란, primary key를 구성하는 모든 컬럼의 값이 다른 컬럼을 결정 짓는 상태. 만약 기본키가 2개인데, 어떤 기본키 컬럼 하나랑만 종속되면 컬럼을 분리한다.

  - 제 3 정규화(3NF) → 제 2 정규화를 진행한 테이블에서 이행적 종속을 없애도록 분리하는 단계이다. A→B, B→C 일 때, A → C가 성립되면 안된다는 것이다. 만약 이렇게 있을 때, 테이블을 (A,B) , (B,C) 두개로 나누어야 한다.


- **반 정규화**

  데이터베이스의 성능 향상을 위해 데이터의 중복을 어느정도 허용하면서 join을 줄여 성능을 향상하는 방식이다.

  join을 줄임으로써 select 속도를 향상시키지만, 유연성이 낮아진다.

  데이터를 검색하게 되면 잦은 join으로 느려질 때가 있는데, join하지 않도록 테이블에 중복된 컬럼을 넣고 검색하는 것이다.


- **DB에서의 상속 관계 표현**

  DB에서의 상속 관계 표현은 논리 모델에서 슈퍼/서브 타입구조로 나타낼 수 있다. 이를 물리 모델로 구현하는 3가지 방법이 있다.

    1. Join 테이블 전략: 상위 테이블과 하위 테이블을 각각 만들고, PK-FK 관계로 연결. 조회 시 JOIN 필요
    2. 단일 테이블 전략:  상위/하위 데이터를 모두 하나의 테이블에 저장. type 컬럼으로 구분
    3. 구현 클래스 테이블 전략:  상위 테이블 없이, 하위 테이블 각각 따로 구현. 공통 속성이 중복됨


- **인덱스**

  데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조이다.

  테이블의 모든 데이터를 검색하면 시간이 오래 걸리기 때문에 데이터와 데이터의 위치를 포함한 자료구조를 생성하여 빠르게 조회할 수 있도록 한다.

  인덱스를 활용하면, select 외에 update, delete의 성능이 향상하는데 이 이유는 해당 연산을 하려면 대상을 조회해야만 작업할 수 있기 때문이다.