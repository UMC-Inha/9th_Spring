## Fetch Join

N+1을 해결하기 위한 가장 대표적이고 확실한 해결책이다. **JPQL**을 사용하여 쿼리를 작성할 때 `JOIN FETCH` 키워드를 사용하면, 처음 엔티티를 조회하는 시점에 연관된 엔티티 데이터까지 **하나의 `JOIN` 쿼리**로 함께 가져올 수 있다.

```java
// UserRepository.java
@Query("SELECT u FROM User u JOIN FETCH u.orders")
List<User> findAllWithOrders();
```

위와 같이 작성하면, `findAllWithOrders()` 호출 시 JPA는 아래와 같은 단 하나의 쿼리를 실행하여 N+1 문제를 원천적으로 차단한다.

```sql
SELECT u.*, o.* FROM user u INNER JOIN orders o ON u.user_id = o.user_id;
```

> **지연 로딩을 적용하고, fetch join을 한다면?**
> 

결론부터 말하면 **fetch join을 사용하면, 지연 로딩 설정이더라도 그 쿼리에서는 즉시 로딩처럼 동작한다.**

> **그냥 즉시 로딩을 적용해서 그냥 한 번에 다 가져오면 되지 않나?**
> 

즉시 로딩은 **연관된 모든 엔티티를 항상 함께 로딩하기 때문에 제어가 불가능하다.** 연관된 객체가 여러 개라면, 실제로 필요하지 않은 데이터까지 모두 한 번에 가져오게 되어 성능이 떨어진다.

즉시 로딩은 “무조건 전부 가져오기” 방식이기 때문에, 즉시 가져오고 싶은 객체가 연관된 일부만이라면 불필요한 조회가 반드시 발생한다.

반면, **지연 로딩을 기본으로 두고 필요한 경우에만 fetch join을 사용하면**, 조회 시점에 **정말 필요한 연관 객체만 선택적으로 함께 조회**할 수 있다. 즉, 불필요한 데이터를 가져오지 않으면서도 필요한 순간에는 효율적으로 즉시 로딩을 수행할 수 있다.