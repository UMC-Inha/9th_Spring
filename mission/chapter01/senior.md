# 미션 1
내가 진행중, 진행 완료한 미션 모아서 보는 쿼리에서 정렬 기준을 1순위는 포인트로 2순위는 최신순으로 하여 Cursor기반 페이지네이션을 구현

```sql
SELECT
  um.mission_id,
  um.status,
  ms.point,
  ms.content,
  st.name AS store_name
FROM user_mission AS um
JOIN mission AS ms
  ON ms.mission_id = um.mission_id
JOIN store AS st
  ON ms.store_id = st.store_id
WHERE um.user_id = ?
  AND um.status IN ('IN_PROGRESS','SUCCESS')
  AND (
        um.accepted_at < ?
     OR (um.accepted_at = ? AND um.mission_id < ?)
  )
ORDER BY ms.point DESC, um.accepted_at DESC
LIMIT ?;

```
    
`ORDER BY`를 사용하면 여러 기준으로 정렬할 수 있는데, **앞에 적은 조건이 우선순위를 가진다.** 따라서 먼저 포인트가 큰 순서대로 정렬한 뒤, 포인트 값이 같을 경우에는 미션을 최근에 받은 순서대로 정렬된다.


# 미션 2 : 트랜잭션 상태와 전파

## 트랜잭션 상태
![이미지](/9th_Spring/mission/chapter01/transaction_status.png)

**활성 (Active)**

트랜잭션이 시작되면 데이터베이스에서 읽기와 쓰기 작업을 할 수 있는 상태가 된다. 이때의 모든 변경 사항은 아직 확정되지 않았고, 필요하다면 언제든 롤백할 수 있다. 즉, 작업이 진행 중인 단계다.

**부분 완료 (Partially Committed)**

트랜잭션의 모든 연산이 끝났을 때, 실제로 데이터베이스에 반영되기 직전 상태다. 내부적으로는 커밋을 준비하는 단계이며, 이 순간 장애가 발생하면 최종 커밋은 되지 않고 롤백될 수 있다.

**완료 (Committed)**

커밋이 정상적으로 끝난 상태다. 이제 트랜잭션에서 수행한 모든 변경 사항이 데이터베이스에 확정되고, 다른 트랜잭션에서도 조회할 수 있게 된다. 트랜잭션이 성공적으로 종료된 단계다.

**실패 (Failed)**

트랜잭션 실행 중 오류가 발생하거나 중단되어 더 이상 진행할 수 없는 상태다. 이 상태에서는 트랜잭션이 성공적으로 커밋될 수 없으며, 롤백 절차가 필요하다.

**철회 (Aborted)**

실패한 트랜잭션에 대해 롤백이 완료된 상태다. 모든 변경 사항이 취소되고 데이터베이스는 트랜잭션 시작 전과 같은 상태로 되돌아간다. 이후 이 트랜잭션은 종료되며 더 이상 작업을 할 수 없다.

## 트랜잭션 전파

트랜잭션 **전파(Propagation)** 는 **이미 실행 중인 트랜잭션이 있는 상황에서 새로운 트랜잭션 요청이 들어왔을 때, 이 둘을 어떻게 연결할지 결정하는 규칙**을 말한다.

스프링을 예로 들면 어떤 메서드에서 `@Transactional`을 사용했는데, 그 메서드가 또 다른 `@Transactional` 메서드를 호출할 때 **기존 트랜잭션을 이어서 쓸지, 끊고 새로 만들지, 아예 트랜잭션 없이 실행할지**를 정하는 방식이 전파다.

### 물리 트랜잭션과 논리 트랜잭션
![이미지](/9th_Spring/mission/chapter01/transaction_type.png)

스프링에서 `@Transactional`을 붙이면 AOP 프록시가 메서드 호출을 감싸면서 **논리 트랜잭션**을 시작한다. 하지만 실제 DB 커넥션 단에서는 매번 새로운 트랜잭션이 열리는 것이 아니라, **여러 논리 트랜잭션이 모여 하나의 물리 트랜잭션을 공유**하게 된다. 따라서 외부 메서드에서 이미 트랜잭션이 시작되어 있다면, 내부 메서드의 `@Transactional`은 별도의 커넥션을 생성하지 않고 기존 물리 트랜잭션에 **합류**한다.

이때 먼저 시작된 트랜잭션을 **외부 트랜잭션**, 그 안에서 실행되는 추가 `@Transactional`을 **내부 트랜잭션**이라고 한다. 내부 트랜잭션은 겉보기에는 독립적인 것처럼 보이지만, 실제로는 동일한 물리 트랜잭션에 종속되어 있다. 따라서 내부 트랜잭션에서 예외가 발생하면 외부 트랜잭션까지 영향을 받아, 결국 전체 물리 트랜잭션이 롤백된다.

마지막으로 물리 트랜잭션은 **DB 커넥션 단위에서 실제로 열리고 commit 또는 rollback으로 종료되는 단위**이며, 이것만이 실제 데이터베이스에 영향을 준다. 여러 논리 트랜잭션이 한 물리 트랜잭션 위에서 동작하기 때문에, 그중 일부라도 실패하면 최종적으로 물리 트랜잭션 전체가 롤백된다.


### 전파 종류
| 옵션           | 기존 트랜잭션 없음       | 기존 트랜잭션 있음              |
|----------------|--------------------------|----------------------------------|
| REQUIRED       | 새로 시작                 | 합류                             |
| REQUIRES_NEW   | 새로 시작                 | 기존 중단, 새로 시작             |
| SUPPORTS       | 트랜잭션 없이 실행        | 합류                             |
| MANDATORY      | 예외 발생                 | 합류                             |
| NOT_SUPPORTED  | 트랜잭션 없이 실행        | 기존 중단 후 비트랜잭션 실행     |
| NEVER          | 트랜잭션 없이 실행        | 예외 발생                        |
| NESTED         | 새로 시작                 | 세이브포인트 생성                |

스프링에서 트랜잭션 전파 옵션은 총 7가지가 있지만, 기본값은 **REQUIRED** 다. 따라서 보통은 새로운 메서드에서 `@Transactional`이 선언되더라도, 이미 실행 중인 트랜잭션이 있으면 그 안으로 **논리 트랜잭션** 이 합류하게 된다. 이때 처음 시작된 트랜잭션을 **신규 트랜잭션(외부 트랜잭션)** 이라고 부르고, 이후 합류하는 것들을 **내부 트랜잭션** 이라고 부를 수 있다.

예를 들어, 로직 A가 송금 기능이라면 A가 신규 트랜잭션을 시작한다. 그 안에서 레포지토리 계층이 실행될 때 생기는 내부 트랜잭션도 모두 같은 물리 트랜잭션에 포함된다. 이어서 로직 C가 로그 저장이라 해도, 기본 전파 속성(REQUIRED)이면 동일한 물리 트랜잭션에 합류한다.

![이미지](/9th_Spring/mission/chapter01/transaction_required.png)

문제는 여기서 발생한다. 만약 로그 저장(로직 C)이 실패하면, 같은 물리 트랜잭션 안에 있는 송금(로직 A)까지 모두 롤백된다. 사용자 입장에서 보면 “로그 저장이 실패했는데 송금까지 실패”하는 것은 말이 안 되는 상황이다.

이런 경우 사용할 수 있는 전파 속성이 **REQUIRES_NEW**다.

![이미지](/9th_Spring/mission/chapter01/transaction_required_new.png)

로그 저장(로직 C)에 `REQUIRES_NEW`를 적용하면, 송금(로직 A)과 그 결과를 DB에 반영하는 과정(로직 B)은 하나의 물리 트랜잭션으로 묶여서 함께 성공/실패한다. 반면 로그 저장(로직 C)은 **별도의 물리 트랜잭션** 에서 실행되므로, 로그 저장이 실패하더라도 본질적인 비즈니스 로직인 송금에는 영향을 주지 않는다.

이처럼 상황에 따라 잘못된 전파 방식을 선택하면 의도치 않게 전체 비즈니스 로직이 롤백될 수 있다. 따라서 반드시 비즈니스 로직의 성격에 맞게 트랜잭션 전파 방식을 선택해야 한다.



# 미션 3
## 함수 기반 인덱스 (Function-based Index)

**함수 기반 인덱스(Function-based Index)** 는 **컬럼에 특정 함수나 계산식을 적용한 결과** 를 저장하는 인덱스 방식이다.

일반 인덱스가 컬럼의 원본 값을 그대로 저장한다면, 함수 기반 인덱스는 `UPPER(컬럼)`이나 `SUBSTR(컬럼, 1, 3)`처럼 **가공된 값** 을 저장한다. 따라서 쿼리에서 동일한 함수나 표현식을 사용하면, 미리 계산된 값을 인덱스에서 바로 활용할 수 있어 성능을 크게 향상시킬 수 있다.

```sql
select r.*, CONCAT(LPAD(r.star, 10, '0'), LPAD(r.review_id, 10, '0')) as cursor_value
from review as r
where CONCAT(LPAD(r.star, 10, '0'), LPAD(r.review_id, 10, '0')) < '00000000030000000052'
order by r.star desc, r.review_id desc
limit 15;
```

원래대로라면 쿼리를 실행할 때마다 `CONCAT(LPAD(r.star, 10, '0'), LPAD(r.review_id, 10, '0'))`를 모든 행에 대해 계산하고, 그 결과를 비교해야 한다. 즉, 매번 각 행마다 이 표현식을 적용한 값을 새로 만들어야 하는 셈이다.

```sql
CREATE INDEX idx_review_cursor
ON review ((CONCAT(LPAD(star, 10, '0'), LPAD(review_id, 10, '0'))));
```

하지만 **함수 기반 인덱스** 를 만들어두면 인덱스를 생성할 때 이미 각 행에 대해 `"0000000004" + "0000000733"` 같은 **가공된 값** 을 미리 계산해 저장한다. 이 값들은 인덱스 내부에서 정렬된 상태로 유지된다.

따라서 쿼리를 실행할 때 DB는 `WHERE ... < '00000000030000000052'` 조건을 만족하는 범위를 인덱스에서 바로 찾아낼 수 있다. 즉, 실행 시점에 매번 계산할 필요 없이 **미리 계산된 값에 곧바로 접근** 할 수 있기 때문에 훨씬 효율적으로 동작한다.

## 복합 인덱스 (Composite Index, 다중 컬럼 인덱스)

**두 개 이상의 컬럼을 묶어서** 인덱스를 만드는 방식이다.

예를 들어 `(col1, col2)`에 인덱스를 만들면, 내부적으로는 `col1`을 기준으로 먼저 정렬되고, 그 안에서 다시 `col2` 순서로 정렬된 인덱스 구조가 생성된다. 따라서 여러 조건이 이 원본 컬럼들에 함께 걸리는 `WHERE` 절에서 효율적으로 동작한다.

```sql
select * from review as r
where r.star < ? or (r.star = ? and r.review_id < ?) # 4 / 4 / 733
order by r.star desc, r.review_id desc
limit 15;
```

이 쿼리는 `ORDER BY r.star DESC, r.review_id DESC`로 두 컬럼을 기준으로 정렬하고,

`WHERE r.star < ? OR (r.star = ? AND r.review_id < ?)` 조건을 통해 커서를 지정한다.

결국 이는 **`star`가 더 작거나, `star`가 같으면 `review_id`가 더 작은 행** 을 찾는 것이므로,

인덱스에서 `(star, review_id)` 조합 순서대로 탐색할 수 있다.

```sql
CREATE INDEX idx_review_star_id ON review (star DESC, review_id DESC);
```

이렇게 복합 인덱스를 생성해 두면, `WHERE` 절의 조건과 `ORDER BY` 절의 정렬을 모두 인덱스에서 처리할 수 있다. 따라서 별도의 정렬 연산이 줄어들고, 전체 쿼리 성능이 크게 향상된다.