# 웹 API 디자인 모범 사례

## **비동기 메서드 구현**

경우에 따라 HTTP 요청이 완료되기까지 시간이 오래 걸릴 수 있다. 서버 입장에서는 큰 문제가 아니지만, 클라이언트 입장에서는 요청 응답을 기다리는 동안 다른 작업을 수행하지 못한다는 점이 불편하다. 이러한 상황에서 하나의 해결책은 **메서드를 비동기식으로 처리**하는 것이다.

![image.png](/mission/chapter03/image/api_design.png)

비동기 처리 방식에서는 클라이언트가 요청을 보내면 서버는 작업을 즉시 처리하지 않고, 우선 요청이 정상적으로 수신되었음을 알리는 **202 Accepted** 응답을 반환한다. 이때 응답의 `Location` 헤더에는 요청의 상태를 확인할 수 있는 별도의 **상태 엔드포인트** URI를 포함한다.

```
HTTP/1.1 202 Accepted
Location: /api/status/12345
```


Location 헤더란?
    
HTTP/1.1 스펙(RFC 7231 등)에 따라 **리다이렉션(3xx)**, **리소스 생성(201 Created)**, 그리고 **비동기 처리(202 Accepted)** 같은 상황에서 **클라이언트에게 다음에 접근할 리소스의 URI**를 알려줄 때 사용하는 헤더다. 즉, 서버가 클라이언트에게 “이 URI를 참고하라”고 알려주는 역할을 한다.

클라이언트는 이후 이 상태 엔드포인트에 주기적으로 `GET` 요청을 보내 작업 진행 상황을 확인할 수 있다. 응답에는 현재 요청의 상태가 포함되며, 필요하다면 예상 완료 시간이나 작업 취소를 위한 링크도 제공할 수 있다.

```
HTTP/1.1 200 OK
Content-Type: application/json

{
    "status": "In progress",
    "link": { "rel": "cancel", "method": "delete", "href": "/api/status/12345" }
}
```

또한 비동기 작업의 결과로 **새로운 리소스가 생성되는 경우**, 상태 엔드포인트는 작업 완료 시점에 **303 See Other** 응답을 반환하고, `Location` 헤더에 새로 생성된 리소스의 URI를 제공한다.

```
HTTP/1.1 303 See Other
Location: /api/orders/12345
```

즉, 클라이언트는 처음 요청에서 바로 결과를 받지 않고, 상태 엔드포인트를 통해 진행 상황을 추적하다가 작업이 완료되면 최종 리소스를 확인하는 방식으로 동작하게 된다.

### 언제 쓰는가?

1. **처리 시간이 길어질 수 있는 작업**
    - 예: 대용량 파일 업로드/처리, 영상 인코딩, 데이터 분석 잡, 머신러닝 모델 학습 등
    - 이런 경우 요청을 즉시 완료할 수 없으니, 클라이언트에게 "요청은 받았어, 진행 상황은 여기서 확인해"라고 알려주는 패턴이다.
    
2. **비동기 백그라운드 작업**
    - 예: 이메일 발송, 알림 푸시, 결제 승인 요청
    - 요청 순간에는 결과가 없지만, 일정 시간이 지나야 성공/실패 여부를 알 수 있는 작업.
    
3. **리소스가 바로 생기지 않는 경우**
    - 예: 주문을 요청했을 때, 내부적으로 여러 시스템과 통신해야 최종 `orderId`가 나오면
    - 처음에는 `202 Accepted`와 상태 엔드포인트(`/status/123`)를 주고, 나중에 다 끝나면 `303 See Other`로 최종 리소스(`/orders/123`)를 알려줄 수 있다.


## **부분 응답 지원**

대규모 리소스(예: 이미지, 동영상, 파일 등)를 다루는 경우, 한 번에 전부 내려주면 **응답 시간이 길어지고**, **네트워크 끊김** 같은 문제에도 취약하다. 이를 해결하기 위한 방법이 바로 **부분 응답(Partial Response) 지원**이다.

### 부분 응답의 원리

클라이언트가 대용량 이미지를 요청하기 전에, 서버가 해당 리소스에 대해 **부분 응답(Partial Response)** 을 지원하는지 확인하고, 실제로 필요한 범위만 나누어 요청하고 싶어한다고 하자

1. **서버가 Accept-Ranges 헤더 제공한다면?**
    - 서버는 특정 리소스가 **바이트 단위 부분 요청(Partial Request)** 을 지원한다는 사실을 알리기 위해, API 응답을 생성할 때 **응답 헤더에 `Accept-Ranges: bytes`를 포함한다.** 이 헤더가 있으면 클라이언트는 해당 리소스가 범위 지정 요청(`Range` 헤더)을 처리할 수 있음을 알게 되고, 이후 필요한 구간만 지정해서 요청할 수 있다.
2. **클라이언트가 HEAD 요청으로 정보 확인**
    - `HEAD` 요청을 보내면 서버는 실제 데이터를 주지 않고, 리소스의 메타정보(크기, 타입, 범위 지원 여부 등)만 응답한다.
        
        ```
        HEAD https://api.contoso.com/products/10?fields=productImage
        ```
        
        ```
        HTTP/1.1 200 OK
        Accept-Ranges: bytes
        Content-Type: image/jpeg
        Content-Length: 4580
        ```
        
    
    - 여기서 `Content-Length`는 리소스의 전체 크기(4580바이트)를 의미하고, `Accept-Ranges`는 해당 리소스가 부분 요청을 지원한다는 사실을 나타낸다. 클라이언트는 이 메타 정보를 보고 리소스를 **한 번에 전부 받을지**, 아니면 **여러 구간으로 나누어 받을지**를 판단해 처리하게 된다.
    
3. **클라이언트가 Range 헤더로 부분 요청**
    - 클라이언트는 한 번에 다 받지 않고, 필요한 범위만 요청하고 싶어 한다.
    - 예시 (처음 0~2499 바이트 요청):
        
        ```
        GET https://api.contoso.com/products/10?fields=productImage
        Range: bytes=0-2499
        ```
        
    - 서버 응답:
        
        ```
        HTTP/1.1 206 Partial Content
        Accept-Ranges: bytes
        Content-Type: image/jpeg
        Content-Length: 2500
        Content-Range: bytes 0-2499/4580
        ```
        
    - 상태코드 **206 Partial Content**는 이번 응답이 전체가 아닌 일부임을 알려준다.
    - `Content-Range`는 전체 크기(4580) 중, 현재 응답이 어느 구간(0–2499)에 해당하는지를 나타낸다.
    
4. **후속 요청으로 나머지 부분 수집**
    - 클라이언트는 이어서 다음 범위(`2500-4579`)를 요청하여 전체 리소스를 점진적으로 다운로드할 수 있다.


## **HATEOAS 구현**

HATEOAS는 REST 아키텍처 제약조건 중 하나로, 클라이언트가 서버와 상호작용할 때 **하이퍼미디어(Hypermedia, 링크 정보)**를 통해 다음에 할 수 있는 액션을 발견하고 실행하도록 하는 원칙을 말한다.

서버가 단순히 데이터만 반환하는 것이 아니라, **관련된 리소스에 접근할 수 있는 링크(URI)**도 함께 제공한다. 클라이언트는 응답에 포함된 링크를 따라가면서 상태를 전이(State Transition)해 나간다. 즉, 클라이언트가 사전에 API 전체 구조를 몰라도, 응답에 담긴 링크를 보고 "다음에 뭘 할 수 있는지"를 알 수 있다.

### HATEOAS 없는 응답

```json
{
  "orderId": 1001,
  "status": "IN_PROGRESS"
}
```

클라이언트는 주문을 취소하려면 `/orders/{id}/cancel` 같은 엔드포인트를 **미리 알고 있어야 한다**.

### HATEOAS 적용 응답

```json
{
  "orderId": 1001,
  "status": "IN_PROGRESS",
  "_links": {
    "self": { "href": "/orders/1001" },
    "cancel": { "href": "/orders/1001/cancel", "method": "POST" },
    "payment": { "href": "/orders/1001/payment", "method": "GET" }
  }
}

```

클라이언트는 응답에 포함된 `_links`를 보고 취소, 결제 등 가능한 액션을 알 수 있다.

즉, **서버가 클라이언트에게 다음 가능한 동작을 안내**하는 것.

클라이언트는 모든 API 경로를 미리 알 필요가 없다. API 구조가 바뀌더라도 서버가 제공하는 링크만 그대로 따라가면 클라이언트는 정상적으로 동작할 수 있다. 이 방식은 REST가 지향하는 **자율적인 탐색(Discoverability)** 을 가능하게 한다.

다만 단점도 있다. 서버가 링크 정보까지 포함해야 하므로 구현이 복잡해지고, 실제 서비스에서는 HATEOAS를 완전히 지키는 경우가 드물다. 또한 클라이언트 쪽에서도 링크를 해석하고 따라가는 로직을 추가해야 하기 때문에 개발 난이도가 높아진다.


## 버전 관리 구현

우리가 만든느 웹 API는 시간이 지나면서 **리소스 구조 변경**이나 **새로운 요구사항**으로 인해 계속 진화한다.

새롭게 만든 API를 API 제공자는 변경을 쉽게 적용할 수 있지만, **기존 클라이언트**는 그 변화를 따라가지 못할 수 있다. 따라서 **새 기능을 제공하면서도 기존 클라이언트를 깨뜨리지 않고 지원**하려면 버전 관리가 필요하다.

### **버전 관리 없음 (No Versioning)**

아래의 응답에 datacreated 라는 필드를 추가하자고 한다.

```json
HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8

{"id":3,"name":"Fabrikam, Inc.","address":"1 Microsoft Way Redmond WA 98053"}
```

```json
HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8

{"id":3,"name":"Fabrikam, Inc.","dateCreated":"2025-03-22T12:11:38.0376089Z","address":"1 Microsoft Way Redmond WA 98053"}
```

API에 새로운 필드를 추가하는 것은 비교적 문제가 발생하지 않는다. 기존 클라이언트는 알 수 없는 필드를 그냥 무시하기 때문에 여전히 정상적으로 동작할 수 있고, 최신 클라이언트는 새 필드를 활용하면 된다. 

반대로, 필드를 삭제하거나 이름을 바꾸는 경우에는 기존 클라이언트가 필요한 값을 찾지 못해 오류가 발생할 수 있다. 또한 단순 문자열로 내려주던 데이터를 복잡한 객체 구조로 바꾸거나, 리소스 간의 관계 자체를 바꾸는 것도 기존 클라이언트가 응답을 해석하지 못하게 만들어 동작을 깨뜨릴 수 있다. 

정리하면, **필드를 추가하는 것은 그나마 괜찮지만, 필드를 없애거나 이름·구조·관계를 바꾸는 것은 호환성을 깨뜨릴 수 있는 위험한 변화**라고 할 수 있다.

### **URI 버전 관리**

웹 API를 수정하거나 리소스의 구조를 바꿀 때는 각 리소스의 URI에 버전 번호를 붙여 새로운 버전을 제공할 수 있다. 예를 들어 `address` 필드를 `streetAddress`, `city`, `state`, `zipCode` 같은 세부 항목으로 나눴다면, 기존 URI는 그대로 두고 새로운 스키마를 반영한 리소스를 `https://api.contoso.com/v2/customers/3`처럼 버전 번호가 붙은 URI에서 제공한다. 이렇게 하면 예전 클라이언트는 기존 URI를 그대로 사용하면서 정상적으로 동작하고, 새로운 클라이언트는 바뀐 구조를 활용할 수 있다.

```
https://api.contoso.com/**v1**/customers/3
https://api.contoso.com/**v2**/customers/3
```

이 방식의 장점은 단순하고 직관적이라는 점이지만, 단점도 있다. URI가 버전마다 달라지므로 REST가 지향하는 "리소스 위치는 변하지 않는다"는 원칙과 맞지 않고, HATEOAS 링크 역시 버전 번호를 모두 포함해야 해서 관리가 복잡해진다.

### **쿼리 문자열 버전 관리**

여러 URI를 따로 만들지 않고, 쿼리 문자열 파라미터로 버전을 지정하는 방법도 있다. 예를 들어 `https://api.contoso.com/customers/3?version=2`처럼 요청하면, `version=2`에 해당하는 리소스 구조를 받을 수 있다. 만약 클라이언트가 버전 정보를 생략하면 기본값을 1로 처리해 이전 버전 리소스를 반환하도록 하면 된다. 

```
https://api.contoso.com/customers/3?version=2
```

이 방식의 장점은 동일한 리소스를 항상 같은 URI에서 접근할 수 있다는 점이다. 하지만 서버에서 쿼리 문자열을 해석해 알맞은 응답을 내려주는 추가 로직이 필요하고, URI 버전 관리와 마찬가지로 HATEOAS 링크를 구현할 때는 모든 링크에 버전 정보를 넣어야 해서 복잡해진다는 단점이 있다.

### **헤더 버전 관리**

버전 번호를 쿼리 문자열로 붙이지 않고, 요청 헤더에 버전을 담아 전달하는 방식도 있다. 

예를 들어 `Custom-Header: api-version=1`처럼 지정하면 1번 버전을, `Custom-Header: api-version=2`라고 하면 2번 버전을 내려주는 식이다. 만약 클라이언트가 헤더를 생략하면 서버가 기본값(예: 1번 버전)으로 처리하도록 할 수 있다.

**api-version1**

```json
GET https://api.contoso.com/customers/3
Custom-Header: api-version=1
```

```json
HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8

{"id":3,"name":"Fabrikam, Inc.","address":"1 Microsoft Way Redmond WA 98053"}
```

**api-version2**

```
GET https://api.contoso.com/customers/3
Custom-Header: api-version=2
```

```json
HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8

{"id":3,"name":"Fabrikam, Inc.","dateCreated":"2025-03-22T12:11:38.0376089Z","address":{"streetAddress":"1 Microsoft Way","city":"Redmond","state":"WA","zipCode":98053}}
```

이 방식의 장점은 동일한 리소스를 항상 같은 URI에서 접근할 수 있다는 점이다. 하지만 서버에서 쿼리 문자열을 해석해 알맞은 응답을 내려주는 추가 로직이 필요하고, URI 버전 관리와 마찬가지로 HATEOAS 링크를 구현할 때는 모든 링크에 버전 정보를 넣어야 해서 복잡해진다는 단점이 있다.

### **미디어 타입 버전 관리 (Content Negotiation)**

클라이언트가 서버에 HTTP GET 요청을 보낼 때는 `Accept` 헤더를 이용해 어떤 형식의 응답을 받을 수 있는지 알려준다. 보통은 JSON, XML 같은 일반적인 포맷을 지정하는데, 이 `Accept` 헤더를 확장해서 **리소스의 버전 정보까지 담는 방법**을 쓸 수 있다.

예를 들어 클라이언트가 다음과 같이 요청한다고 해보자.

```
GET https://api.contoso.com/customers/3
Accept: application/vnd.contoso.v1+json
```

여기서 `application/vnd.contoso.v1+json`은 **컨텐츠 타입**이면서 동시에 버전 정보도 포함한다.

- `vnd.contoso.v1` → 리소스 버전 1을 요청한다는 뜻
- `json` → 응답 포맷은 JSON

서버는 이 헤더 값을 확인하고 맞는 버전의 리소스를 내려준다. 그리고 응답에서는 `Content-Type` 헤더에 동일한 정보를 포함시켜 어떤 형식으로 내려보냈는지 명시한다.

```
HTTP/1.1 200 OK
Content-Type: application/vnd.contoso.v1+json; charset=utf-8

{"id":3,"name":"Fabrikam, Inc.","address":"1 Microsoft Way Redmond WA 98053"}
```

만약 클라이언트가 잘못된 미디어 타입을 지정했거나 서버가 지원하지 않는 버전을 요청하면, 서버는 **406 Not Acceptable** 응답을 줄 수도 있고, 기본값(예: 최신 안정 버전)으로 응답을 줄 수도 있다.

이 방식의 장점은, 단순히 URI를 바꾸지 않고도 버전 정보를 관리할 수 있다는 점이고, 특히 HATEOAS에서 **링크와 MIME 타입을 함께 표현**할 수 있어서 잘 어울린다.

## 다중 테넌트 웹 API

다중 테넌트(Multi-Tenancy) 웹 API는 **여러 조직(테넌트)이 하나의 API를 공유해 사용하는 구조**를 말한다.

쉽게 말해, 하나의 웹 API 서버가 있다고 하자. 이 서버를 **A 회사, B 회사 같은 여러 조직**이 동시에 사용한다. 하지만 **A 회사의 데이터와 B 회사의 데이터가 섞이면 안 되기 때문에**, API는 요청이 들어올 때마다

- "이건 A 회사의 요청이다"
- "이건 B 회사의 요청이다"

라고 식별한다. 이렇게 해서 각 테넌트(=조직)별로 데이터를 **격리해서 안전하게 사용하는 것**이 다중 테넌트 웹 API다.

### **하위 도메인 또는 도메인 기반 격리 사용(DNS 수준 테넌트)**

하위 도메인 또는 도메인 기반 격리 방식은 테넌트별 도메인을 사용해 요청을 라우팅하는 방법이다. 가장 일반적인 방식은 와일드카드 도메인을 이용해 `tenant1.api.example.com`, `tenant2.api.example.com`처럼 하위 도메인을 사용하는 것이다. 이 방법은 단순하고 유연하여 빠르게 다중 테넌트를 지원할 수 있다. 

반면, 각 테넌트가 직접 소유한 사용자 지정 도메인을 사용하는 방식도 있는데, 이 경우 `api.tenant-company.com`처럼 별도의 주소를 통해 접근하게 된다. 사용자 지정 도메인은 조직의 브랜드를 반영할 수 있고, 보다 세밀한 제어가 가능하다는 장점이 있다. 

두 방식 모두 `A`와 `CNAME` 레코드 같은 적절한 DNS 구성을 통해 트래픽을 올바른 인프라로 유도한다. 와일드카드 도메인은 관리와 구성이 단순하다는 장점이 있지만, 사용자 지정 도메인은 각 테넌트에게 맞춤형 환경을 제공할 수 있다. 또한 역방향 프록시와 백엔드 서비스 간에는 반드시 호스트 이름을 유지해야 URL 리디렉션 문제를 방지하고 내부 인프라 구조가 외부에 노출되는 것을 막을 수 있다. 

이러한 방식은 테넌트별 요청을 올바르게 라우팅하는 데 도움이 되며, DNS 확인 절차 자체가 데이터 보존 정책이나 규정 준수를 충족하는 데도 중요한 역할을 한다.

```
GET https://adventureworks.api.contoso.com/orders/3
```

 `adventureworks.api.contoso.com`이라는 하위 도메인을 통해 이 요청이 adventureworks 테넌트의 요청임을 식별할 수 있다.

### **테넌트별 HTTP 헤더 전달**

테넌트 정보를 **HTTP 헤더**에 담아 전달하는 방식이 있다. 예를 들어 `X-Tenant-ID: companyA`라는 헤더를 추가하면 “이 요청은 companyA 조직의 것이다”라고 식별할 수 있다. 이 정보는 직접 정의한 헤더(`X-Tenant-ID`, `X-Organization-ID`)에 넣을 수도 있고, JWT 토큰 안에 담아 전달할 수도 있다.

이 방식은 요청마다 헤더를 확인해야 하므로 **계층 7(L7) 게이트웨이** 같은 장치가 필요하다. 따라서 트래픽이 많아질수록 검사 비용이 늘어난다는 단점이 있다.

하지만 장점도 크다. 인증을 중앙에서 일괄 관리할 수 있고, SDK나 클라이언트를 이용하면 테넌트 정보가 자동으로 처리되므로 클라이언트 쪽 구현이 단순해진다. 또한 URI에 테넌트 정보를 노출하지 않아도 되기 때문에 API 주소를 더 깔끔하고 RESTful하게 유지할 수 있다.

다만 **캐싱 문제**는 주의해야 한다. 대부분의 캐시 시스템은 URL만 기준으로 응답을 저장하기 때문에, 헤더를 구분하지 않으면 A 회사의 데이터가 잘못 캐시되어 B 회사에 전달되는 상황이 발생할 수 있다. 이는 곧 **데이터 유출**로 이어질 수 있다.

결국, 헤더 기반 방식은 깔끔한 API 설계와 보안 관리 측면에서 장점이 많지만, 캐시 전략을 제대로 설계하지 않으면 성능 저하나 보안 문제가 발생할 수 있다는 점을 반드시 고려해야 한다.

```
GET https://api.contoso.com/orders/3
X-Tenant-ID: adventureworks
```

```
GET https://api.contoso.com/orders/3
Host: adventureworks
```

```
GET https://api.contoso.com/orders/3
Authorization: Bearer <JWT-token including a tenant-id: adventureworks claim>
```

### **URI 경로를 통해 테넌트별 정보 전달**

이 방법은 **URI 경로에 테넌트 식별자를 포함하는 방식**이다. 즉, 리소스 경로에 테넌트 ID를 넣고, API 게이트웨이나 역방향 프록시가 해당 경로 세그먼트를 분석해 어떤 테넌트의 요청인지 판단한다. 경로 기반 격리는 구현이 단순하고 명확하지만, RESTful한 API 디자인을 해치고 라우팅 로직이 복잡해질 수 있다. 특히 URI를 구문 분석하고 표준화하려면 정규식이나 패턴 매칭 같은 추가 처리가 필요한 경우가 많다.

```
GET https://api.contoso.com/tenants/adventureworks/orders/3
```

반대로 **헤더 기반 격리**는 HTTP 헤더를 활용해 `X-Tenant-ID: companyA`처럼 키-값 쌍 형태로 테넌트 정보를 전달한다. 이 방식은 URI가 깔끔하게 유지되며 RESTful 설계에도 더 잘 맞는다.

두 방식 모두 공통적으로 인프라 자원을 효율적으로 공유할 수 있고, 운영 비용을 줄이며 대규모 다중 테넌트 웹 API 환경에서 성능을 높이는 데 도움이 된다.


## **API에서 분산 추적 기능 및 추적 컨텍스트 기능 사용 설정**

마이크로서비스 아키텍처에서는 하나의 요청이 인증, 주문, 결제, 알림 등 여러 서비스를 거쳐 처리된다. 그렇다 보니 문제가 생겼을 때 어느 서비스에서 오류가 발생했는지, 혹은 어디서 지연이 발생했는지를 파악하기가 쉽지 않다. 

이를 해결하기 위해 요청마다 고유한 식별자(ID)를 붙이고, 이 값을 서비스 간 호출 시 함께 전달하는 방식을 사용한다. 대표적으로 `Correlation-ID`, `Request-ID`, `Trace-ID`와 `Span-ID` 같은 헤더가 쓰인다. 

```
GET https://api.contoso.com/orders/3
Correlation-ID: aaaa0000-bb11-2222-33cc-444444dddddd

```

예를 들어 클라이언트가 `Correlation-ID`를 요청 헤더에 담아 보내면, 서버는 같은 값을 응답 헤더에 포함시켜 반환한다. 이렇게 하면 클라이언트에서 시작된 요청이 여러 서비스를 거쳐 처리되는 과정을 하나의 흐름으로 추적할 수 있다.

```
HTTP/1.1 200 OK
...
Correlation-ID: aaaa0000-bb11-2222-33cc-444444dddddd

```

이 방식의 장점은 네 가지로 정리할 수 있다. 첫째, 엔드 투 엔드 가시성을 확보할 수 있어 요청이 어떤 서비스들을 거쳤는지를 한눈에 파악할 수 있다. 둘째, 장애가 발생했을 때 같은 `Correlation-ID`로 로그를 묶어 확인하면 문제 지점을 쉽게 찾을 수 있다. 셋째, 각 구간별 응답 시간을 측정해 병목 구간을 식별하는 성능 모니터링이 가능하다. 마지막으로 서비스 간 호출 관계를 분석해 어떤 서비스가 어떤 서비스에 의존하는지 파악할 수 있다.

실제 구현에서는 Spring Cloud Sleuth와 Zipkin, Jaeger와 OpenTelemetry 같은 도구를 사용하면 Trace-ID와 Span-ID를 자동으로 관리할 수 있다. 또한 API를 설계할 때 요청과 응답 헤더에 `Correlation-ID`와 `Trace-ID`를 포함시키면, 클라이언트와 서버가 남긴 로그를 쉽게 연결할 수 있어 분산 환경에서도 효율적으로 추적과 진단을 할 수 있다.

