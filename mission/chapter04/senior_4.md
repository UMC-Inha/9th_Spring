# 다양한 락킹 전략

동시성 문제를 해결하기 위한 방법으로 Lock 을 거는 방법은 대표적인 방법이다 

락킹 전략은 여러 사용자가 동시에 같은 데이터에 접근할 때 발생할 수 있는 데이터 불일치나 충돌을 막기 위한 기술입니다. 크게 **비관적 락(Pessimistic Lock)** 과 **낙관적 락(Optimistic Lock)** 으로 나뉘며, 환경과 목적에 따라 다양한 방식으로 구현됩니다.

---

## 1. 비관적 락 (Pessimistic Lock)

**"충돌은 빈번하게 발생할 것이므로, 데이터에 접근하는 순간부터 락을 걸어 다른 접근을 막아야 한다"** 는 비관적인 관점의 전략입니다. 데이터의 정합성을 매우 높은 수준으로 보장합니다.

데이터를 읽는 시점부터 트랜잭션이 끝날 때까지 해당 데이터에 배타적인 잠금(Exclusive Lock)을 겁니다. 락이 걸린 동안 다른 트랜잭션은 해당 데이터를 읽거나 수정할 수 없으며 대기해야 합니다.

- **DB 레벨**: `SELECT ... FOR UPDATE` (SQL)
    
    ```sql
    -- 트랜잭션 시작
    BEGIN;
    -- id=100인 상품 row에 락을 겁니다.
    SELECT * FROM products WHERE id = 100 FOR UPDATE;
    -- 재고 차감 로직 수행
    UPDATE products SET stock = stock - 1 WHERE id = 100;
    -- 트랜잭션 종료 시 락 해제
    COMMIT;
    ```
    
- **JPA**: `@Lock(LockModeType.PESSIMISTIC_WRITE)`
    
    ```java
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("select p from Product p where p.id = :id")
    Optional<Product> findByIdForUpdate(Long id);
    ```
    
- **장점**:
    - **강력한 정합성 보장**: 락을 선점하므로 데이터가 중복되거나 잘못 수정될 가능성이 원천적으로 차단됩니다.
    - **구현 용이**: 로직이 비교적 단순하고 직관적입니다.
- **단점**:
    - **성능 저하**: 락이 해제될 때까지 다른 트랜잭션들이 대기해야 하므로, 동시 처리 성능이 떨어집니다.
    - **데드락 (Deadlock)**: 두 개 이상의 트랜잭션이 서로의 락이 해제되기를 기다리는 교착 상태에 빠질 수 있습니다.
- **주요 사용처**: 충돌이 자주 발생할 것으로 예상되는 시스템, 금전 처리나 재고 관리처럼 데이터 정합성이 매우 중요한 경우에 사용됩니다.

---

## 2. 낙관적 락 (Optimistic Lock)

**"충돌은 거의 발생하지 않을 것이므로, 일단 작업을 허용하고 마지막에 데이터가 변경되었는지 확인하자"**는 낙관적인 관점의 전략입니다.

데이터에 **버전(Version)** 정보를 추가하여 관리합니다. 데이터를 수정할 때, 내가 처음 읽었던 버전과 현재 데이터의 버전이 동일한 경우에만 업데이트를 허용합니다. 버전이 다르면 다른 트랜잭션이 먼저 수정한 것이므로 현재 작업을 실패 처리합니다.

- **JPA**: `@Version` 어노테이션
    
    ```java
    @Entity
    public class Board {
        @Id
        private Long id;
        private String content;
    
        @Version // JPA가 자동으로 버전을 관리합니다.
        private Integer version;
    }
    ```
    
    **동작 예시**
    
    1. 사용자 A가 `id=1`, `version=1`인 게시글을 읽습니다.
    2. 사용자 B가 동시에 `id=1`, `version=1`인 게시글을 읽습니다.
    3. 사용자 B가 게시글을 수정하고 저장합니다. DB에는 `version=2`로 업데이트됩니다.
    4. 사용자 A가 게시글을 수정하고 저장하려고 시도합니다. 이때 자신이 읽었던 `version=1`과 DB의 현재 `version=2`가 다르므로 JPA는 예외(`ObjectOptimisticLockingFailureException`)를 발생시키고 업데이트를 실패 처리합니다.

- **장점**:
    - **높은 동시성**: 데이터를 직접 잠그지 않으므로 여러 트랜잭션이 동시에 데이터를 읽고 수정 작업을 시도할 수 있어 성능이 좋습니다.
- **단점**:
    - **충돌 시 처리 복잡**: 업데이트가 실패했을 때(버전 불일치), 개발자가 직접 재시도 로직을 구현하거나 사용자에게 오류를 알려주는 등의 후처리 로직이 필요합니다.
    - **잦은 충돌 시 비효율**: 충돌이 빈번하게 발생하면 계속해서 업데이트에 실패하고 재시도하게 되므로, 오히려 비관적 락보다 성능이 나빠질 수 있습니다.
- **주요 사용처**: 읽기 작업이 수정 작업보다 훨씬 많고, 충돌 발생 확률이 낮은 서비스(예: 게시글 수정, 상품 정보 조회)에 적합합니다.

---

## 3. 기타 락 전략

### 네임드 락 (Named Lock)

데이터베이스의 특정 행(Row)이 아닌, 개발자가 지정한 **문자열(String)**에 대해 락을 획득하고 해제하는 방식입니다. 주로 데이터베이스가 제공하는 함수(예: MySQL의 `GET_LOCK()`)를 사용합니다.

- **특징**: 테이블이나 데이터 레코드와는 독립적으로, 특정 로직 자체의 동시 실행을 막고 싶을 때 유용합니다.
- **예시**: "회원 ID 123번이 가게 456번을 찜하는 행위" 자체를 막기 위해 `'like_store_123_456'`이라는 문자열에 락을 걸 수 있습니다.

### 분산 락 (Distributed Lock)

애플리케이션 서버가 여러 대인 분산 환경에서는 개별 서버 내부의 락(Java의 `synchronized` 등)이나 단일 DB의 락만으로는 동시성을 완벽히 제어할 수 없습니다. 이때는 모든 서버가 공유하는 외부 시스템을 이용해 락을 관리합니다.

- **구현**: **Redis**의 `SETNX`(SET if Not eXists) 명령어나 **Zookeeper**, **etcd** 같은 분산 코디네이션 서비스를 활용하여 구현합니다.
- **필요성**: 여러 서버에 걸쳐 동일한 자원에 대한 접근을 제어해야 할 때 반드시 필요합니다.