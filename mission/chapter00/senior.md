# API 에서 방어

## Idempotency-Key 패턴

멱등성(idempotent)이란 동일한 요청을 몇 번 반복해서 보내더라도 결과가 항상 동일하게 유지되는 성질을 말한다. `Idempotency-Key` 패턴은 바로 이 멱등성을 보장하기 위한 방법 중 하나다.

서버는 클라이언트로부터 요청을 받을 때 매번 `Idempotency-Key`(또는 `X-Idempotency-Key`)라는 고유 키를 함께 받는다. 서버는 이 키를 **(userId, resource, action)** 같은 맥락 정보와 함께 캐시나 DB에 기록해 두고, 해당 요청의 처리 상태와 결과를 저장한다. 이후 동일한 키로 재요청이 들어오면 실제 로직을 다시 실행하지 않고 **이미 저장된 결과를 그대로 반환**한다.

<aside>

**첫 번째 요청**

- 서버가 `Idempotency-Key`를 확인한다.
- 이 키로 기록된 내역이 없다면 → 실제 비즈니스 로직을 실행하고 결과를 저장한다.

**두 번째 요청 (같은 키)**

- 서버가 `Idempotency-Key`를 확인한다.
- 이미 같은 키로 처리된 기록이 있다면 → 비즈니스 로직을 **다시 실행하지 않고**, 저장된 결과를 그대로 반환한다.
</aside>

여러 번 요청이 들어와도 서버는 이를 “한 번의 요청”으로 취급해 동일한 결과를 일관되게 보장할 수 있다.

## 서버측 중복 탐지 키(비즈니스 키)

`비즈니스 키` 방식은 사실상 `Idempotency-Key` 패턴과 유사하지만, 더 **비즈니스 로직에 밀접하게 결합된 키**를 사용하는 방법이다. 예를 들어, 회원가입을 처리한다고 해보자.

- 사용자가 `email = test@example.com`으로 가입 요청을 보냈다.
- 그런데 네트워크 문제나 연타 때문에 같은 요청이 두 번 서버로 전달될 수 있다.
- 이때 서버는 `email`을 비즈니스 키로 보고, 이미 같은 이메일로 가입된 사용자가 있다면 두 번째 요청은 무시하거나 동일한 결과를 반환한다.

즉 `email`이 “이 회원가입은 단 한 번만 유효하다”는 **비즈니스적으로 고유한 식별자** 역할을 하는 것이다.

### **Idempotency-Key vs 비즈니스 키**

**Idempotency-Key는** 주로 클라이언트가 단순 UUID를 생성해서 요청마다 붙인다. 요청을 받은 서버는 이 키를 기반으로 요청을 캐싱해 “같은 요청은 같은 응답”을 보장한다. 범용적이고, 네트워크·재시도 상황 방어에 특화되어 있다. 반면 **비즈니스 키**는 비즈니스 규칙에서 고유해야 하는 값 자체를 키로 활용한다. 예로 들면 회원가입(email), 결제(orderId), 미션 시작(userId + missionId 조합)이 있을 수 있다. 단순히 요청 중복 방어뿐 아니라, **업무적으로 중복되면 안 되는 상황**까지 자연스럽게 막아준다.

`Idempotency-Key`는 **요청 단위의 멱등성**을 보장하는 범용 패턴, `비즈니스 키`는 **도메인 규칙 기반 멱등성**을 보장하는 특화 패턴이다. 둘 다 하면 더 좋다!


# DB·트랜잭션 레벨 방어

## **유니크 제약(UNIQUE)으로 중복 삽입 원천 차단**

### **PostgreSQL — 부분(조건부) UNIQUE 인덱스**

보통 인덱스는 단순히 데이터를 **빠르게 검색하기 위한 색인** 역할을 한다.

하지만 인덱스에 **`UNIQUE` 제약**을 걸면 단순 속도 향상을 넘어서 **중복을 허용하지 않는 제약 조건**으로도 활용할 수 있다. 

```sql
CREATE UNIQUE INDEX CONCURRENTLY ux_user_mission_active
  ON user_mission(user_id, mission_id)
  WHERE state IN ('STARTED','IN_PROGRESS');  
```

위의 쿼리는 `user_mission` 테이블에서 `user_id`와 `mission_id` 조합에 대해 인덱스를 생성하는데, 그중에서도 `state` 값이 `'STARTED'`나 `'IN_PROGRESS'`인 행만 인덱스에 포함된다.

따라서 특정 유저가 특정 미션을 이미 **활성 상태**로 가지고 있다면, 같은 `(user_id, mission_id)` 조합으로 또다시 삽입하려고 할 때 UNIQUE 인덱스 제약에 걸려 중복 삽입이 허용되지 않는다.

즉, **활성 상태는 동시에 하나만 존재할 수 있도록** DB 차원에서 강제하는 것이다.

### **MySQL — 생성 칼럼 + UNIQUE (부분 인덱스 미지원 우회)**

MySQL에서는 PostgreSQL처럼 인덱스를 조건부로 부분 생성할 수 없기 때문에, 이를 우회하기 위해 **생성 칼럼(Generated Column)**을 사용한다. 생성 칼럼은 실제 데이터를 별도로 저장하지 않고 기존 컬럼 값을 기반으로 자동 계산되는 가상 칼럼으로, 마치 계산식의 결과를 테이블의 일반 컬럼처럼 활용할 수 있게 해준다. 생성 칼럼에는 두 가지 유형이 있는데, **VIRTUAL**은 디스크에 저장되지 않고 조회 시마다 계산되는 방식이고, **STORED**는 계산된 결과가 디스크에 저장되어 인덱스를 걸 수 있는 방식이다. 따라서 MySQL에서 인덱스를 적용하려면 반드시 STORED 생성 칼럼을 사용해야 한다.

```sql
ALTER TABLE user_mission
  ADD COLUMN active_flag TINYINT(1)
    GENERATED ALWAYS AS (
      CASE WHEN state IN ('STARTED','IN_PROGRESS') THEN 1 ELSE NULL END
    ) STORED,
  ADD UNIQUE KEY ux_user_mission_active (user_id, mission_id, active_flag);
```

이렇게 하면 `(user_id, mission_id, active_flag)` 조합에 대해 UNIQUE 제약이 적용된다. 따라서 `state`가 `'STARTED'` 또는 `'IN_PROGRESS'`일 때는 `active_flag = 1`이 되어 유니크 제약 조건에 걸리게 되고, 같은 `(user_id, mission_id)` 조합이 다시 들어오면 삽입이 차단된다. 반면 비활성 상태에서는 `active_flag = NULL`이 되는데, MySQL의 UNIQUE 인덱스에서는 `NULL` 값끼리는 중복으로 취급되지 않으므로 제약이 적용되지 않는다. 이 경우 동일한 `(user_id, mission_id)` 조합이 여러 번 삽입될 수 있기 때문에, 이는 **비즈니스 로직에 따라 허용될 수도 있고, 허용되지 않아야 할 수도 있다.**

## 안전한 삽입(업서트)로 “하나만 성공”

간단히 말하면, **UNIQUE 제약에 의해 중복 삽입이 차단된 이후 그 상황을 어떻게 처리할지 결정하는 것**이 바로 안전한 삽입(업서트)이다. 이때 선택지는 여러 가지가 있다.

- **무시**: 중복이 발생하면 아무 작업도 하지 않고 조용히 넘어간다.
- **덮어쓰기**: 기존 행을 UPDATE하여 새로운 값으로 갱신한다.
- **에러 반환**: 중복임을 명확히 알려주고 애플리케이션이 후속 처리를 하도록 한다.

업서트를 사용하면 단순히 “중복 삽입을 막는다”에서 끝나는 것이 아니라, **그 이후를 어떻게 처리할지까지 미리 정의**할 수 있다. 이를 통해 동시 요청, 네트워크 재시도, 버튼 연타 같은 상황에서도 DB가 깨끗하게 정리된 상태를 유지하고, 애플리케이션 입장에서도 예측 가능한 방식으로 결과를 받을 수 있다.