### 2️⃣ 기존과 @DynamicInsert, @DynamicUpdate 적용 시 장단점 파악하기

## @DynamicInsert 장단점

### 장점

1. **DB 기본값을 살릴 수 있다.**
    
    created_at, status, count 등 DB에서 `DEFAULT`를 주고 싶은 컬럼에 유용하다.
    
    자바 쪽에서 값을 설정하지 않으면 → 아예 컬럼을 INSERT에 넣지 않으므로,
    
    DB 기본값(예: `DEFAULT 'ACTIVE'`, `DEFAULT CURRENT_TIMESTAMP`)이 깔끔하게 적용된다.
    
2. **“값을 안 준 것”과 “null을 명시적으로 쓰는 것”을 구분할 수 있다.**
    
    
3. **널 컬럼이 많은 테이블에서 네트워크/전송량이 약간 줄어들 수 있다.**
    
    아주 넓은 테이블(wide table)에 nullable 컬럼이 많고, 
    
    그중 소수만 실제로 채워넣는 경우에 약간의 이득이 있을 수 있다.
    

### 단점

1. **SQL 재사용성 저하 → 성능에 악영향이 될 수도 있다.**
    
    조합마다 다른 INSERT 문이 생성되므로,
    
    DB 쿼리 캐시(Execution Plan cache)와 Hibernate 쿼리 캐시 히트율이 낮아질 수 있다.
    
2. “**null을 정말로 넣고 싶은 경우**”가 곤란해진다.
    
    dynamicInsert는 “null이면 컬럼을 빼버리는” 전략이므로,
    
    DB 기본값이 있는 컬럼에 **명시적으로 null을 넣고 싶을 때** 의도와 다를 수 있다.
    
3. **비즈니스 로직이 DB와 애플리케이션 사이에 분산된다.**
    
    일부 기본값은 Java 코드에서, 일부 기본값은 DB DEFAULT에서 관리하면,
    
    어느 쪽에서 어떤 값을 넣는지 추적이 어려워질 수 있다.
    


## @DynamicUpdate 장단점

### 장점

1. **실제로 변경된 컬럼만 UPDATE → 불필요한 쓰기를 줄일 수 있다.**
    
    특히 매우 넓은 테이블에서, 일부 필드만 바꾸는 일이 많을 때 의미가 있다.
    
    특정 DB에서는 변경되지 않은 컬럼을 건드리지 않음으로써 
    
    인덱스/저널/undo 로그 등에서 유리한 경우가 있을 수 있다.
    
2. **트리거나 감사(audit) 로직과 결합 시 유용한 경우가 있다.**
    
    DB 트리거가 “특정 컬럼 변경 시에만 동작”하도록 되어 있다면,
    
    해당 컬럼만 SET에 포함하는 것이 더 의미론적으로 깔끔하다.
    
3. **동시성 관점에서 “실제로 변한 값만 바꾸는” 것이 좀 더 자연스러운 경우가 있다.**
    
    물론 optimistic locking은 여전히 version 컬럼 기준으로 처리되므로,
    
    동시성 제어 자체가 강화되는 것은 아니지만, “불필요한 값 덮어쓰기”는 피할 수 있다.
    

### 단점

1. **쿼리 캐시/statement 캐시 효율 저하**
    
    변경되는 필드 조합에 따라 UPDATE SQL이 달라지므로, SQL 파싱/플랜 캐싱 측면에서 손해를 볼 수 있다.
    
    일반적인 시스템에서는 이 비용이 이득보다 더 클 수 있다.
    
2. **디버깅/로그 가독성이 떨어질 수 있다.**
    
    상황마다 다른 UPDATE 문이 찍히므로,
    
    “어떤 필드가 언제, 어떻게 업데이트 되었는지” 추적이 어렵게 느껴질 수 있다.
    
3. **복잡한 엔티티일수록 쿼리 패턴이 더 다양해진다.**
    
    넓은 엔티티에다 dynamicUpdate까지 걸면 쿼리 조합 수가 기하급수적으로 늘어나며,
    
    오히려 튜닝/분석이 어려워질 수 있다.
    

---

